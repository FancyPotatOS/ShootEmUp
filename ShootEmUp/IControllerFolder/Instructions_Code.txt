

ControlsHandler

Load:

// NECESSARY
    controls_handler_gui = Content.Load<Texture2D>("controls_handler_gui");

// SYMBOLS ASSIGNED TO EACH CONTROL
    udlr = new Texture2D[] { Content.Load<Texture2D>("up"), Content.Load<Texture2D>("down"), Content.Load<Texture2D>("left"), Content.Load<Texture2D>("right") };


Update:
(Has variable hasConnected that signifies it is currently assigning controls)
(Has variables p1, p2, or any IController[])
(Has string[] for all names of the controls)

[Everything that must always be run]


    if (!hasConnected)
    {
        bool finished = IController.Connect(new IController[] { p1, p2 }, new string[] { "up", "down", "left", "right" });

        if (finished)
        {
            hasConnected = true;
        }
        else
        {
            base.Update(gameTime);
            return;
        }
    }

[Everything that cannot be run while connecting]



Draw:
(Has IController[] for controls)
(Has Texture2D controls_handler_gui)
(Has Texture2D[] for all symbols of the keys to be assigned)

[Everything that must be drawn (Like a background)]

    if (!hasConnected)
    {
        GraphicsDevice.Clear(Color.CornflowerBlue);

        _spriteBatch.Begin(SpriteSortMode.Deferred, null, SamplerState.LinearWrap, null, null, null, null);

        foreach (ToDraw td in IController.GetDrawing(this, new IController[] { p1, p2 }, controls_handler_gui, udlr))
        {
            Texture2D tex = td.tex;
            Rectangle bound = td.bound;
            Color color = td.color;

            _spriteBatch.Draw(tex, bound, color);
        }

        _spriteBatch.End();

        base.Draw(gameTime);

        return;
    }

[Everything that must not be drawn when assigning controls]